var documenterSearchIndex = {"docs":
[{"location":"#BcdiCore.jl-Documentation","page":"Main","title":"BcdiCore.jl Documentation","text":"","category":"section"},{"location":"#About","page":"Main","title":"About","text":"","category":"section"},{"location":"","page":"Main","title":"Main","text":"Bragg Coherent Diffraction Imaging (BCDI) Core implements some of the core functionality used for future projects BcdiAtomic.jl (an atomic scale BCDI solver), BcdiMeso.jl (a mesoscale BCDI Solver), BcdiMulti.jl (a multiscale BCDI solver), and BcdiTrad.jl (a BCDI solver using projection algorithms). BcdiCore.jl implements the loss functions and derivatives of loss functions used in these packages.","category":"page"},{"location":"","page":"Main","title":"Main","text":"While this package is marked as BCDI specific, the methods are more general and can be used in many phase retrieval problems. In the future, this package may be incorporated into a more general phase retrieval core package.","category":"page"},{"location":"","page":"Main","title":"Main","text":"Currently, this entire package must be run with access to GPUs. This may change in the future (especially if Issues requesting it are opened), but for our research group, using GPUs is a necessity.","category":"page"},{"location":"#Installation","page":"Main","title":"Installation","text":"","category":"section"},{"location":"","page":"Main","title":"Main","text":"Currently, BcdiCore.jl is not registered in the Julia general registry. BcdiCore.jl can be installed by running in the REPL package manager (]):","category":"page"},{"location":"","page":"Main","title":"Main","text":"add git@github.com:byu-cig/BcdiCore.jl.git","category":"page"},{"location":"use/#Overview","page":"Usage","title":"Overview","text":"","category":"section"},{"location":"use/","page":"Usage","title":"Usage","text":"In general, BcdiCore.jl will be called by developers of phase retrieval codes, not end users. BcdiCore.jl implements loss functions and derivatives of loss functions for atomic models, mesoscale models, multiscale models, and traditional projection-based methods.","category":"page"},{"location":"use/#Available-loss-functions","page":"Usage","title":"Available loss functions","text":"","category":"section"},{"location":"use/","page":"Usage","title":"Usage","text":"Currently, BcdiCore.jl implements two types of losses, the average L_2 norm and the average log-likelihood. ","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"Explicitly, the average L_2 loss is defined as","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"L_2 = frac1N sum_u left( lvert G(u) rvert - lvert F(u) rvert right)^2","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"where G(u) is the simulated electric field, lvert F(u) rvert^2 is the measured intensity at a point u in reciprocal space, and N is the total number of meaurement points.","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"The average log-likelihood (for the Poisson distribution) is defined as","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"ell = frac1N sum_u lvert G(u) rvert^2 - lvert F(u) rvert^2 lnleft(lvert G(u) rvert^2 right)","category":"page"},{"location":"use/#Atomic-Models","page":"Usage","title":"Atomic Models","text":"","category":"section"},{"location":"use/#Mathematical-Definitions","page":"Usage","title":"Mathematical Definitions","text":"","category":"section"},{"location":"use/","page":"Usage","title":"Usage","text":"For the atomic model, G(u) is defined as","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"G(hkl) = sum_j e^-i (x_j (h+G_h) + y_j (k+G_k) + z_j (l+G_l)) ","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"where x_j y_j z_j are atom positions and hkl represent a distance away from some scattering vector G_h G_k G_l in reciprocal space. It is important that the hkl value are integers and that they range from -fracn2 to fracn2-1, so both real space and reciprocal space positions must be scaled. The x_jy_jz_j positions should be shifted to lie between 0 to 1 and should be multiplied by 2pi to capture the missing 2 pi scaling in the Fourier transform exponent.","category":"page"},{"location":"use/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"use/","page":"Usage","title":"Usage","text":"Calculating the loss function and its derivative for the atomic model is done in three steps. First, the BcdiCore.AtomicState struct is created. Then, the atom positions are set by calling BcdiCore.setpts!. Finally, the loss function is calculated with BcdiCore.loss.","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"state = AtomicState(lossType, scale, intens, G, h, k, l)\nsetpts!(state, x, y, z, getDeriv)\nlossVal = loss(state, getDeriv, getLoss)","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"If the derivative is requested with the getDeriv variable, the results are stored in state.xDeriv,  state.yDeriv, and state.zDeriv.","category":"page"},{"location":"use/#Mesoscale-Models","page":"Usage","title":"Mesoscale Models","text":"","category":"section"},{"location":"use/#Mathematical-Definitions-2","page":"Usage","title":"Mathematical Definitions","text":"","category":"section"},{"location":"use/","page":"Usage","title":"Usage","text":"Similar to the atomic model, G(u) is initially defined as","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"G(hkl) = sum_j e^-i (x_j (h+G_h) + y_j (k+G_k) + z_j (l+G_l)) ","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"where x_j y_j z_j are atom positions and hkl represent a distance away from some scattering vector G_h G_k G_l in reciprocal space. However, x_j y_j z_j can be thought of as an addition of lattice spacings and displacement vectors, i.e.  x_j+ux_j y_j+uy_j z_j+uz_j. Then, if G_hG_kG_l are reciprocal lattice vectors, we find that x cdot G is an integer multiple of 2pi, so it does not affect the simulated electric field. We are then left with","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"G(hkl) = sum_j e^-i (x_j G_h + y_j G_k + uz_j G_l) e^-i (ux_j (h+G_h) + uy_j (k+G_k) + uz_j (l+G_l)) ","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"Coarse graining to get a mesoscale model, we get","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"G(hkl) = sum_j rho_j e^-i (x_j h + y_j k + uz_j l) e^-i (ux_j (h+G_h) + uy_j (k+G_k) + uz_j (l+G_l)) ","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"Again, it is important that the hkl value are integers and that they range from -fracn2 to fracn2-1, so both real space and reciprocal space positions must be scaled. The x_jy_jz_j positions should be shifted to lie between 0 to 1 and should be multiplied by 2pi to capture the missing 2 pi scaling in the Fourier transform exponent.","category":"page"},{"location":"use/#Usage-2","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"use/","page":"Usage","title":"Usage","text":"Calculating the loss function and its derivative for the mesoscale model is done in three steps. First, the BcdiCore.MesoState struct is created. Then, the atom positions are set by calling BcdiCore.setpts!. Finally, the loss function is calculated with BcdiCore.loss.","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"state = MesoState(lossType, scale, intens, G, h, k, l)\nsetpts!(state, x, y, z, rho, ux, uy, uz, getDeriv)\nlossVal = loss(state, getDeriv, getLoss)","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"If the derivative is requested with the getDeriv variable, the results are stored in state.rhoDeriv, state.uxDeriv,  state.uyDeriv, and state.uzDeriv.","category":"page"},{"location":"use/#Traditional-Models","page":"Usage","title":"Traditional Models","text":"","category":"section"},{"location":"use/#Mathematical-Definitions-3","page":"Usage","title":"Mathematical Definitions","text":"","category":"section"},{"location":"use/","page":"Usage","title":"Usage","text":"Similar to the mesoscale model, G(u) is initially defined as","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"G(hkl) = sum_j rho_j e^-i (x_j h + y_j k + uz_j l) e^-i (ux_j (h+G_h) + uy_j (k+G_k) + uz_j (l+G_l)) ","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"where x_j y_j z_j are real space positions, ux_j uy_j uz_j are diplacement vectors, and hkl represent a distance away from some scattering vector G_h G_k G_l in reciprocal space. However, we assume that, because the distance from the scattering vector and the displacement vectors are small, u cdot h is negligible. So we are left with","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"G(hkl) = sum_j rho_j e^-i (x_j h + y_j k + uz_j l) e^-i (ux_j G_h + uy_j G_k + uz_j G_l) ","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"Then, we combine the entire rho_j e^-i (ux_j G_h + uy_j G_k + uz_j G_l) quantity as one variable and get","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"G(hkl) = sum_j psi_j e^-i (x_j h + y_j k + uz_j l) ","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"In this case, this is an ordinary Fourier transform, so we put the factor of 2pi back into G(hkl) to get","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"G(hkl) = sum_j psi_j e^-2 pi i (x_j h + y_j k + uz_j l) ","category":"page"},{"location":"use/#Usage-3","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"use/","page":"Usage","title":"Usage","text":"Calculating the loss function and its derivative for the traditional model is done in two steps. First, the BcdiCore.TradState struct is created. Then, the loss function is calculated with BcdiCore.loss.","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"state = TradState(losstype, scale, intens, realSpace)\nlossVal = loss(state, getDeriv, getLoss)","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"If the derivative is requested with the getDeriv variable, the result us stored in state.deriv.","category":"page"},{"location":"use/#Multiscale-Models","page":"Usage","title":"Multiscale Models","text":"","category":"section"},{"location":"use/#Mathematical-Definitions-4","page":"Usage","title":"Mathematical Definitions","text":"","category":"section"},{"location":"use/","page":"Usage","title":"Usage","text":"The multiscale model is a combination of an atomic scale and a mesoscale model. In this case,  G(hkl) is defined as","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"G(hkl) = G_a(hkl) + G_m(hkl)","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"where a signifies the atomic model and m signifies the mesoscale model.","category":"page"},{"location":"use/#Usage-4","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"use/","page":"Usage","title":"Usage","text":"Calculating the loss function and its derivative for the mesoscale model is done in three steps. First, the BcdiCore.MultiState struct is created. Then, the atom positions are set by calling BcdiCore.setpts!. Finally, the loss function is calculated with BcdiCore.loss.","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"state = MultiState(lossType, scale, intens, G, h, k, l)\nsetpts!(state, x, y, z, mx, my, mz, rho, ux, uy, uz, getDeriv)\nlossVal = loss(state, getDeriv, getLoss)","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"Here x, y, z are atomic positions and mx, my, mz are the real space locations of the mesoscale model.","category":"page"},{"location":"use/","page":"Usage","title":"Usage","text":"If the derivative is requested with the getDeriv variable, the results are stored in state.xDeriv,  state.yDeriv, and state.zDeriv, state.rhoDeriv, state.uxDeriv,  state.uyDeriv, and state.uzDeriv.","category":"page"}]
}
