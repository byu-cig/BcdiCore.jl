<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · BcdiCore.jl</title><meta name="title" content="Usage · BcdiCore.jl"/><meta property="og:title" content="Usage · BcdiCore.jl"/><meta property="twitter:title" content="Usage · BcdiCore.jl"/><meta name="description" content="Documentation for BcdiCore.jl."/><meta property="og:description" content="Documentation for BcdiCore.jl."/><meta property="twitter:description" content="Documentation for BcdiCore.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BcdiCore.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Main</a></li><li class="is-active"><a class="tocitem" href>Usage</a><ul class="internal"><li><a class="tocitem" href="#Available-loss-functions"><span>Available loss functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Atomic-Models"><span>Atomic Models</span></a></li><li><a class="tocitem" href="#Mathematical-Definitions"><span>Mathematical Definitions</span></a></li><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li class="toplevel"><a class="tocitem" href="#Mesoscale-Models"><span>Mesoscale Models</span></a></li><li><a class="tocitem" href="#Mathematical-Definitions-2"><span>Mathematical Definitions</span></a></li><li><a class="tocitem" href="#Usage-2"><span>Usage</span></a></li><li class="toplevel"><a class="tocitem" href="#Traditional-Models"><span>Traditional Models</span></a></li><li><a class="tocitem" href="#Mathematical-Definitions-3"><span>Mathematical Definitions</span></a></li><li><a class="tocitem" href="#Usage-3"><span>Usage</span></a></li><li class="toplevel"><a class="tocitem" href="#Multiscale-Models"><span>Multiscale Models</span></a></li><li><a class="tocitem" href="#Mathematical-Definitions-4"><span>Mathematical Definitions</span></a></li><li><a class="tocitem" href="#Usage-4"><span>Usage</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/byu-cig/BcdiCore.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/byu-cig/BcdiCore.jl/blob/main/docs/src/use.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h1><p>In general, BcdiCore.jl will be called by developers of phase retrieval codes, not end users. BcdiCore.jl implements loss functions and derivatives of loss functions for atomic models, mesoscale models, multiscale models, and traditional projection-based methods.</p><h2 id="Available-loss-functions"><a class="docs-heading-anchor" href="#Available-loss-functions">Available loss functions</a><a id="Available-loss-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Available-loss-functions" title="Permalink"></a></h2><p>Currently, BcdiCore.jl implements two types of losses, the average <span>$L_2$</span> norm and the average log-likelihood. </p><p>Explicitly, the average <span>$L_2$</span> loss is defined as</p><p class="math-container">\[L_2 = \frac{1}{N} \sum_u \left( \lvert G(u) \rvert - \lvert F(u) \rvert \right)^2\]</p><p>where <span>$G(u)$</span> is the simulated electric field, <span>$\lvert F(u) \rvert^2$</span> is the measured intensity at a point <span>$u$</span> in reciprocal space, and <span>$N$</span> is the total number of meaurement points.</p><p>The average log-likelihood (for the Poisson distribution) is defined as</p><p class="math-container">\[\ell = \frac{1}{N} \sum_u \lvert G(u) \rvert^2 - \lvert F(u) \rvert^2 \ln{\left(\lvert G(u) \rvert^2 \right)}\]</p><h1 id="Atomic-Models"><a class="docs-heading-anchor" href="#Atomic-Models">Atomic Models</a><a id="Atomic-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Atomic-Models" title="Permalink"></a></h1><h2 id="Mathematical-Definitions"><a class="docs-heading-anchor" href="#Mathematical-Definitions">Mathematical Definitions</a><a id="Mathematical-Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Definitions" title="Permalink"></a></h2><p>For the atomic model, <span>$G(u)$</span> is defined as</p><p class="math-container">\[G(h,k,l) = \sum_j e^{-i (x_j (h+G_h) + y_j (k+G_k) + z_j (l+G_l))} \\\]</p><p>where <span>$x_j, y_j, z_j$</span> are atom positions and <span>$h,k,l$</span> represent a distance away from some scattering vector <span>$G_h, G_k, G_l$</span> in reciprocal space. It is important that the <span>$h,k,l$</span> value are integers and that they range from <span>$-\frac{n}{2} \to \frac{n}{2}-1$</span>, so both real space and reciprocal space positions must be scaled. The <span>$x_j,y_j,z_j$</span> positions should be shifted to lie between <span>$0 \to 1$</span> and should be multiplied by <span>$2\pi$</span> to capture the missing <span>$2 \pi$</span> scaling in the Fourier transform exponent.</p><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>Calculating the loss function and its derivative for the atomic model is done in three steps. First, the <code>BcdiCore.AtomicState</code> struct is created. Then, the atom positions are set by calling <code>BcdiCore.setpts!</code>. Finally, the loss function is calculated with <code>BcdiCore.loss</code>.</p><pre><code class="nohighlight hljs">state = AtomicState(lossType, scale, intens, G, h, k, l)
setpts!(state, x, y, z, getDeriv)
lossVal = loss(state, getDeriv, getLoss)</code></pre><p>If the derivative is requested with the <code>getDeriv</code> variable, the results are stored in <code>state.xDeriv</code>,  <code>state.yDeriv</code>, and <code>state.zDeriv</code>.</p><h1 id="Mesoscale-Models"><a class="docs-heading-anchor" href="#Mesoscale-Models">Mesoscale Models</a><a id="Mesoscale-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Mesoscale-Models" title="Permalink"></a></h1><h2 id="Mathematical-Definitions-2"><a class="docs-heading-anchor" href="#Mathematical-Definitions-2">Mathematical Definitions</a><a class="docs-heading-anchor-permalink" href="#Mathematical-Definitions-2" title="Permalink"></a></h2><p>Similar to the atomic model, <span>$G(u)$</span> is initially defined as</p><p class="math-container">\[G(h,k,l) = \sum_j e^{-i (x&#39;_j (h+G_h) + y&#39;_j (k+G_k) + z&#39;_j (l+G_l))} \\\]</p><p>where <span>$x&#39;_j, y&#39;_j, z&#39;_j$</span> are atom positions and <span>$h,k,l$</span> represent a distance away from some scattering vector <span>$G_h, G_k, G_l$</span> in reciprocal space. However, <span>$x&#39;_j, y&#39;_j, z&#39;_j$</span> can be thought of as an addition of lattice spacings and displacement vectors, i.e.  <span>$x_j+ux_j, y_j+uy_j, z_j+uz_j$</span>. Then, if <span>$G_h,G_k,G_l$</span> are reciprocal lattice vectors, we find that <span>$x \cdot G$</span> is an integer multiple of <span>$2\pi$</span>, so it does not affect the simulated electric field. We are then left with</p><p class="math-container">\[G(h,k,l) = \sum_j e^{-i (x_j G_h + y_j G_k + uz_j G_l)} e^{-i (ux_j (h+G_h) + uy_j (k+G_k) + uz_j (l+G_l))} \\\]</p><p>Coarse graining to get a mesoscale model, we get</p><p class="math-container">\[G(h,k,l) = \sum_j \rho_j e^{-i (x_j h + y_j k + uz_j l)} e^{-i (ux_j (h+G_h) + uy_j (k+G_k) + uz_j (l+G_l))} \\\]</p><p>Again, it is important that the <span>$h,k,l$</span> value are integers and that they range from <span>$-\frac{n}{2} \to \frac{n}{2}-1$</span>, so both real space and reciprocal space positions must be scaled. The <span>$x&#39;_j,y&#39;_j,z&#39;_j$</span> positions should be shifted to lie between <span>$0 \to 1$</span> and should be multiplied by <span>$2\pi$</span> to capture the missing <span>$2 \pi$</span> scaling in the Fourier transform exponent.</p><h2 id="Usage-2"><a class="docs-heading-anchor" href="#Usage-2">Usage</a><a class="docs-heading-anchor-permalink" href="#Usage-2" title="Permalink"></a></h2><p>Calculating the loss function and its derivative for the mesoscale model is done in three steps. First, the <code>BcdiCore.MesoState</code> struct is created. Then, the atom positions are set by calling <code>BcdiCore.setpts!</code>. Finally, the loss function is calculated with <code>BcdiCore.loss</code>.</p><pre><code class="nohighlight hljs">state = MesoState(lossType, scale, intens, G, h, k, l)
setpts!(state, x, y, z, rho, ux, uy, uz, getDeriv)
lossVal = loss(state, getDeriv, getLoss)</code></pre><p>If the derivative is requested with the <code>getDeriv</code> variable, the results are stored in <code>state.rhoDeriv</code>, <code>state.uxDeriv</code>,  <code>state.uyDeriv</code>, and <code>state.uzDeriv</code>.</p><h1 id="Traditional-Models"><a class="docs-heading-anchor" href="#Traditional-Models">Traditional Models</a><a id="Traditional-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Traditional-Models" title="Permalink"></a></h1><h2 id="Mathematical-Definitions-3"><a class="docs-heading-anchor" href="#Mathematical-Definitions-3">Mathematical Definitions</a><a class="docs-heading-anchor-permalink" href="#Mathematical-Definitions-3" title="Permalink"></a></h2><p>Similar to the mesoscale model, <span>$G(u)$</span> is initially defined as</p><p class="math-container">\[G(h,k,l) = \sum_j \rho_j e^{-i (x_j h + y_j k + uz_j l)} e^{-i (ux_j (h+G_h) + uy_j (k+G_k) + uz_j (l+G_l))} \\\]</p><p>where <span>$x_j, y_j, z_j$</span> are real space positions, <span>$ux_j, uy_j, uz_j$</span> are diplacement vectors, and <span>$h,k,l$</span> represent a distance away from some scattering vector <span>$G_h, G_k, G_l$</span> in reciprocal space. However, we assume that, because the distance from the scattering vector and the displacement vectors are small, <span>$u \cdot h$</span> is negligible. So we are left with</p><p class="math-container">\[G(h,k,l) = \sum_j \rho_j e^{-i (x_j h + y_j k + uz_j l)} e^{-i (ux_j G_h + uy_j G_k + uz_j G_l)} \\\]</p><p>Then, we combine the entire <span>$\rho_j e^{-i (ux_j G_h + uy_j G_k + uz_j G_l)}$</span> quantity as one variable and get</p><p class="math-container">\[G(h,k,l) = \sum_j \psi_j e^{-i (x_j h + y_j k + uz_j l)} \\\]</p><p>In this case, this is an ordinary Fourier transform, so we put the factor of <span>$2\pi$</span> back into <span>$G(h,k,l)$</span> to get</p><p class="math-container">\[G(h,k,l) = \sum_j \psi_j e^{-2 \pi i (x_j h + y_j k + uz_j l)} \\\]</p><h2 id="Usage-3"><a class="docs-heading-anchor" href="#Usage-3">Usage</a><a class="docs-heading-anchor-permalink" href="#Usage-3" title="Permalink"></a></h2><p>Calculating the loss function and its derivative for the traditional model is done in two steps. First, the <code>BcdiCore.TradState</code> struct is created. Then, the loss function is calculated with <code>BcdiCore.loss</code>.</p><pre><code class="nohighlight hljs">state = TradState(losstype, scale, intens, realSpace)
lossVal = loss(state, getDeriv, getLoss)</code></pre><p>If the derivative is requested with the <code>getDeriv</code> variable, the result us stored in <code>state.deriv</code>.</p><h1 id="Multiscale-Models"><a class="docs-heading-anchor" href="#Multiscale-Models">Multiscale Models</a><a id="Multiscale-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Multiscale-Models" title="Permalink"></a></h1><h2 id="Mathematical-Definitions-4"><a class="docs-heading-anchor" href="#Mathematical-Definitions-4">Mathematical Definitions</a><a class="docs-heading-anchor-permalink" href="#Mathematical-Definitions-4" title="Permalink"></a></h2><p>The multiscale model is a combination of an atomic scale and a mesoscale model. In this case,  <span>$G(h,k,l)$</span> is defined as</p><p class="math-container">\[G(h,k,l) = G_a(h,k,l) + G_m(h,k,l)\]</p><p>where <span>$a$</span> signifies the atomic model and <span>$m$</span> signifies the mesoscale model.</p><h2 id="Usage-4"><a class="docs-heading-anchor" href="#Usage-4">Usage</a><a class="docs-heading-anchor-permalink" href="#Usage-4" title="Permalink"></a></h2><p>Calculating the loss function and its derivative for the mesoscale model is done in three steps. First, the <code>BcdiCore.MultiState</code> struct is created. Then, the atom positions are set by calling <code>BcdiCore.setpts!</code>. Finally, the loss function is calculated with <code>BcdiCore.loss</code>.</p><pre><code class="nohighlight hljs">state = MultiState(lossType, scale, intens, G, h, k, l)
setpts!(state, x, y, z, mx, my, mz, rho, ux, uy, uz, getDeriv)
lossVal = loss(state, getDeriv, getLoss)</code></pre><p>Here <code>x, y, z</code> are atomic positions and <code>mx, my, mz</code> are the real space locations of the mesoscale model.</p><p>If the derivative is requested with the <code>getDeriv</code> variable, the results are stored in <code>state.xDeriv</code>,  <code>state.yDeriv</code>, and <code>state.zDeriv</code>, <code>state.rhoDeriv</code>, <code>state.uxDeriv</code>,  <code>state.uyDeriv</code>, and <code>state.uzDeriv</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Main</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Saturday 13 July 2024 01:59">Saturday 13 July 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
